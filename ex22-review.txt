5 Reasons You Should Use ri To Read Ruby Documentation
help in ruby -> ri open
http://www.jstorimer.com/blogs/workingwithcode/7766081-5-reasons-you-should-use-ri-to-read-ruby-documentation

------------------------------------------------------

EX1: Printing

$ ruby -v : to check ruby version.

$ irb : to run Interactive Ruby Shell

puts : command to print a statement

'' : single quotes

" " : double quotes

------------------------------------------------------

EX2: Comments and Pound Characters

# : single line comment

=begin : multiple line comment
any
text
=end

puts "Hi # there."
The # in the above code is inside a string.
These pound or hash (#) characters are just considered characters and aren't considered comments.

------------------------------------------------------

EX3: Numbers and Math

+ plus
- minus
/ forward slash
\ backward slash
* asterisk
% percent
< less-than
> greater-than
<= less-than-equal
>= greater-than-equal

"Operations" means things like add, subtract, multiply, divide, squaring, etc.
If it isn't a number it is probably an operation.

### PEMDAS ###
NOTE: order of operations is PEMDAS (ex: please excuse my dear aunt sally)
which stands for Parentheses Exponents Multiplication Division Addition Subtraction.

P - Parentheses first ()
E - Exponents (ie Powers and Square Roots, etc.) - 2 power of 3 - 2 x 2 x 2 = 8
MD - Multiplication and Division (left-to-right)
AS - Addition and Subtraction (left-to-right)

ex: puts "What is 3 + 2? #{3 + 2}"
The use of #{3+2} in the code above is how you insert Ruby computations(the action of mathematical calculation) into text strings.
You can put anything that is Ruby code between the { (left-bracket) and } (right-bracket)
characters and Ruby will run it and put the result of 3 + 2 there instead of those characters #{ } .

puts 3 + 2 + 1 - 5 + 4 % 2 - 1 / 4 + 6
above code displays 7 as the result once run,
since it's order of operations is PEMDAS

There are no fractions, only whole numbers.
You need to use a "floating point" number
which is a number with a decimal point, as in 10.5, or 0.89, or even 3.0.
puts 3 + 2 + 1 - 5 + 4 % 2 - 0.1 / 4 + 6  displays result as 6.975
puts 3 + 2 + 1 - 5 + 4 % 2 - 1.0 / 4 + 6  displays result as 6.75

% character a "modulus" and not a "percent"
In programming this calculation is typically done with simple division and the / operator.
The % modulus is a different operation that just happens to use the % symbol.
For example, "100 divided by 16 with 4 remaining."
The result of % is the remaining part 4.

------------------------------------------------------

EX4: Variables And Names

variable is any line of code where you set a name = (equal) to a value.
In programming a variable is nothing more than a name for something.
Programmers use these variable names to make their code read more like English.

example:
cars = 100  :cars is the variable name and 100 is it's value, 100 is assigned to cars.
where ever you use cars you are using 100.
space_in_a_car = 4.0   #floating point '.' is used in 4.0 to make it a fraction.
drivers = 30
passengers = 90
cars_not_driven = cars - drivers  :you can use variables to do mathematical calculation. minus in this case.
cars_driven = drivers
carpool_capacity = cars_driven * space_in_a_car  :you can use variables to do mathematical calculation. multiply in this case
average_passengers_per_car = passengers / cars_driven :you can use variables to do mathematical calculation. division is this case

The = (single-equal) assigns the value on the right to a variable on the left.
The == (double-equal) tests if two things have the same value.

# variables can be called into the string " " with #{ }
puts "There are #{cars} cars available."


------------------------------------------------------

EX5: More Variables and Printing

Every time you put " (double-quotes) around a piece of text you have been making a string.
A string is how you make something that your program might give to a human.
You print strings, save strings to files, send strings to web servers, and many other things.

my_name = 'Chalasani'  :if value is a name ex: 'Chalasani' assigned to variable it should be in single quotes ''
my_age = 35  : if value is a number assigned to variable no single or double quotes required.

puts "Let's talk about #{my_name}."  :
You embed variables inside a string by using a special #{} sequence and then put the variable you want inside the {} characters ex: #{my_name}.
This tells Ruby, "Hey, this string needs to be formatted. Put these variables in there to display it's value."

puts "Do you know, i am #{my_age} years old." : displays the value from variable my_age.

puts "If I add #{my_age}, #{my_height}, and #{my_weight} I get #{my_age + my_height + my_weight}."
In the above line values of (my_age, my_height, my_weight) variables are displayed and then addition of the values in the three variables.

------------------------------------------------------

EX6: Strings and Text

Strings can contain any number of variables that are in your Ruby script.
A string is usually a bit of text you want to display to someone, or "export" out of the program you are writing.

short and cryptic (or) short abbreviated variable names : example: x = "word" and y = 10

? Explain why adding the two strings w and e with + makes a longer string.
This is called concatenation, and it basically says take the first part and add it to the second part.
Since it's not mathematical or adding numbers, it interprets it as "take the first string and add the second string to it,
 not mathematically but put them side by side.

? Find all the places where a string is put inside a string
There are four places with literal "string" insertion (binary, do_not, x & y)

? formats  #{types_of_people} or Like this: #{variable_name}.
There is another way to put variables directly into a string, using that fancy term I mentioned before; string interpolation.
That really just means "hey, when you see these characters together, it means take the variable value and replace it inside the string.
 The format for doing that is to use the "# hash" character

------------------------------------------------------

EX7: More Printing

puts "Its fleece was white as #{'show'}."

In the above string, #{'show'} is not a variable it is just a word SHOW.
variables will not have single-quotes around them.

In ruby the double-quotes tells ruby to replace variable with values it finds with #{}.
but the single-quotes tells ruby to leave the string along and ignore are variable inside it.

print vs. puts : The primary difference between them is that puts adds a newline after executing, and print does not.

------------------------------------------------------

EX8: Printing, Printing

format string with #{} or %{}

you will almost always use #{} to format your strings, but there are times when you
want to apply the same format to multiple values. That's when %{} comes in handy.

formatter is just name of the variable, you can put anil if u want
we can put the formatter inside the formatter.

------------------------------------------------------

EX9:

\n to display string in new line.

------------------------------------------------------

EX10: What Was That?

: Escape sequence by adding \ backslash to single & double quotes
or just use triple quotes """  """ at the start and end of the string.

Escape double-quote inside string by add \ in-front of double-quote
puts "I am 6'2\" tall."

Escape single-quote-quote inside string by add \ in-front of single-quote
puts 'I am 6\'2" tall.'

\t : for Horizontal tab effect for text
\n : (backslash n) new line character
\  : split single line and displays into two lines ex: persian_cat = "I'm split\non a line."
     I'm split
     on a line.
\b : back space
\f : form feed
\r : carriage return
\v : vertical tab
\a : makes a bell noise

cannot comment in the """ string
cannot put #{} in '''

Use ''' when you need a multi-line string that contains #{} formatting,
.. but you don't want them to be processed yet or at all.

Use """ for all other multi-line strings.

------------------------------------------------------

EX11: Asking Questions

If you PRINT a statement and use gets.chomp in next step,
it will prompt you to input at the end of statement

If you use puts to display the statement and use gets.chomp in the next step,
it will prompt you to input in the next line.

we can use gets.chomp.to_i to get numbers as input to do math.

gets : this method will wait till you enter the input, once you hit enter key, text entered
will be passed to Variable as value. if you just use gets it will add newline (\n) automatically
to the end of the string. ruby literally adds's newline once you hit enter key to the end of your input.

.chomp : this method will avoid creation of newline (\n) that's why we use gets.chomp
it displays all inputs enter to answer multiple questions with multiple enter key hits, in 1 line.

------------------------------------------------------

EX12: Prompting People for Numbers

to take numbers as input, we can add .to_i to the gets.chomp and it will convert into integer.
we can also save what gets.chomp returns, and call .to_i on that, ex: what we did with number = another.to_i

Floating values: use gets.chomp.to_f to get floating values like ex: 10.30

------------------------------------------------------

EX13: Parameters, Unpacking, Variables

You know how you type ruby ex13.rb to run the ex13.rb file? Well the ex13.rb part of the command is called an "argument."

In first, second, third = ARGV   (first, second, third are variables)
and ARGV is the "argument variable," This argument variable holds the arguments you pass to your Ruby script ($ruby ex13.rb first 2nd 3rds) when you run it.

Line 1 "unpacks" ARGV so that, rather than holding all the arguments, it gets assigned to three variables you can work with: first, second, and third.
It just says, "Take whatever is in ARGV, unpack it, and assign it to all of these variables on the left in order."

Change your script to use $stdin.gets.chomp, from now on since the action gets.chomp has problems with ARGV.

command line arguments come in as strings.

for numbers use gets.chomp.to_i

------------------------------------------------------

EX14: Prompting and Passing

when using one command line argument only use this format:
ex: ARGV.first   (first can be changed to anything)

when using multiple command line arguments you can use this format:
ex: first, second, third = ARGV [or] first, second = ARGV

we have declared the variable prompt with sting '> '  or you can use double quotes
ex: prompt = "> "
later in the script when we asked a question we waited with prompt for user input.
ex: puts prompt  rather than typing prompt = '>' ins the script again and again.

A comma for puts is like using puts twice
we can also write puts like this ex: puts "Where do you live #{user_name}", prompt

Since there is ARGV (argument variable) in this script, we are using stdin.gets.chomp
instead of just gets.chomp

we have used """ style to write multiline string with #{} format activator.

------------------------------------------------------

EX15: Reading Files

when we execute ex15.rb file, ex15.rb will read text from ex15_sample.txt file and print it out.
ex15.rb will "open" ex15_sample.txt into our script and print it out.

we are not "hard coding" ex15_sample.txt into ex15.rb,
since we want flexibility of calling any file.

solution is to use ARGV or gets.chomp to ask the user what file to open instead of
"hard coding" the file's name in ex15.rb

since we are asking to enter only one file name in command line argument,
we are using filename = ARGV.first

***** txt = open(filename)
"open" will open the file ex15_sample.txt into ex15.rb but not the file contents,
it actually makes something called a "file object".
file object is like a dvd player but not a dvd.

puts "Here's your file #{filename}:" will print name of the file.

"Read" reads the content of the file. you can assign the result to a variable.
"read" is a function that we called on txt, by using open in txt = open(filename)
we get the file into txt. file(txt) also have commands you can give it, you give a file a
command by using the . (dot or period), the name of the command, and parameters.
just like open(filename) open is the command and (filename) is the parameter.
just like gets.chomp where gets.chomp is the command and chomp is the parameter.

In txt.read txt is the file and read is the command, function or method,
the difference is that txt.read says, "Hey txt ! Do your read command
with NO parameters!"

ruby will not restrict you from opening a file more than once. sometimes this is required.

filename = ARGV.first or filename = gets.chomp which way is better?
If we are writing automation script,
by using ARGV we can give the file name at the start as argument and let the script run for 1000 times.
if we give the file name in the middle with gets.chomp some one should be there to give 1000 times.

------------------------------------------------------

EX16: Reading and writing files

commands(methods/functions) that can be given to files.
close -- Closes the file. like File -> Save.. in your editor
read -- Reads the contents of the file. you can assign the result to a variable.
readline -- Reads just one line of a text file.
truncate -- Empties the file. Watch out if you care about the file.
write('stuff') -- Writes "stuff" to the file.

some of the above commands take parameters, but we do not care about that.
write takes a parameter of a string you want to write to the file.

$stdin.gets creates one line empty space in command line.

target.write(line1 + "\n" + line2 + "\n" + line3 + "\n")
# one line to cut the repetition in script ex16.rb line 45 to 50.

Find out why we had to pass a 'w' as an extra parameter to open.
Hint: open tries to be safe by making you explicitly say you want to write a file.
[By us asking to write a file, it in addition to making sure we are writing
to the file also physically creates the file in the same step]

* 'w' will create a new file if 6_a_test.txt is given as argument, if it doesn't exists.

If you open the file with 'w' mode, then do you really need the target.truncate()?
[I commented out the option for target truncate, and the script worked the same.
So no, it is not necessary to run the truncate command if we open the file with 'w' access.
The danger of course is that we will wipe out whatever is in there,
which might not be our goal. Here's where it pays to make sure :). ]

'w' write mode
'r' read mode
'a' for append

modifiers to the file modes can i use?
most important one to know for now is the + modifier
'w+', 'r+' and 'a+' . This will open the file in both read and write mode,
and depending on the character use position the file in different ways.

open(filename) open's it in 'r' (read) mode by default, for the open() function.

------------------------------------------------------

EX17: More Files
